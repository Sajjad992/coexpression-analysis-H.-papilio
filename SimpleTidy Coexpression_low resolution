# ============================================================
# üß¨ Gene Co-expression Network Construction_ new version_ low resolution
# Author: [sajjad]
# Description: This script computes gene-gene coexpression 
#              networks centered around bait genes by SimpleTidy workflow and 
#              detects coexpression modules via Leiden clustering.
# ============================================================

# -------------------------------
# 0Ô∏è‚É£ Setup
# -------------------------------
source("scripts/FUNCTIONS.R")   # custom helper functions
suppressPackageStartupMessages({
  library(tidyverse)
  library(igraph)
  library(furrr)
  library(ggraph)
  library(tidygraph)
  library(patchwork)
  library(reshape2)
})

# Parameters
r_cutoff <- 0.9
minGenes <- 5
n_samples <- 9
set.seed(123)

# -------------------------------
# 1Ô∏è‚É£ Load expression and metadata
# -------------------------------
files <- list.files(
  pattern = "Exp_table_long_averaged_z_\\d+\\.tsv$",
  full.names = TRUE
)

Exp_table_long_averaged_z <- files %>%
  map(~ read_delim(.x, delim = "\t", show_col_types = FALSE)) %>%
  bind_rows()

metadata <- read_delim("metadata.txt",
                       col_names = c("replicateName", "tissue", rep(".", 3))) %>%
  select(replicateName, tissue) %>%
  mutate(tissue = gsub("_|\\s+", "", tissue),
         TissueOrdered = factor(
           tissue,
           levels = c("Root", "Basalplate", "Innerbulb",
                      "Youngleaf", "Oldleaf", "Flowerstalk",
                      "Petal", "Peduncle", "Pistil"))
  )

# -------------------------------
# 2Ô∏è‚É£ Load and clean bait gene list
# -------------------------------
Baits <- read_delim("baitall.txt", delim = "\t", col_names = TRUE) %>%
  mutate(gene_ID = sub("_i\\d+$", "", `Transcript ID`)) %>%
  select(gene_ID, Gene_name = Gene)
write_delim(Baits, "bait_genes_clean.tsv", delim = "\t")
str(Baits)
length(Baits)
# -------------------------------
# 3Ô∏è‚É£ Compute correlations (bait vs all)
# -------------------------------
z_score_wide <- Exp_table_long_averaged_z %>%
  select(gene_ID, tissue = SampleName, z.score.TPM) %>%
  pivot_wider(names_from = tissue, values_from = z.score.TPM) %>%
  as.data.frame()

nreps <- ncol(z_score_wide) - 1

correlation_against_baits <- sapply(Baits$gene_ID, simplify = FALSE, \(x) {
  dBait <- t(as.matrix(filter(z_score_wide, gene_ID == x)[-1]))
  dOthers <- t(as.matrix(filter(z_score_wide, gene_ID != x)[-1]))
  
  data.frame(correlation = cor(dBait, dOthers) %>% t) %>%
    mutate(Gene1 = x,
           Gene2 = filter(z_score_wide, gene_ID != x)$gene_ID,
           r2 = correlation^2,
           t = correlation * sqrt((nreps - 2) / (1 - r2)),
           p.value = 2 * pt(-abs(t), df = nreps - 2),
           FDR = p.adjust(p.value, "fdr"),
           significant = FDR < 0.01)
}) %>% list_rbind()

# -------------------------------
# 4Ô∏è‚É£ Visualize correlation distribution
# -------------------------------
correlation_against_baits %>%
  ggplot(aes(x = correlation)) +
  geom_histogram(fill = "black", bins = 100) +
  geom_vline(xintercept = r_cutoff, color = "red", linewidth = 0.8) +
  labs(title = "Bait Gene Correlations", x = "Correlation (r)") +
  theme_classic(base_size = 14)
ggsave("plots/BaitGene_Correlation_Distribution.png", width = 6, height = 4)
if (!dir.exists("results")) dir.create("results")
# -------------------------------
# 5Ô∏è‚É£ Build all-vs-all correlation network (polished)
# -------------------------------

# create results/plots folders if missing
dir.create("results", showWarnings = FALSE)
dir.create("plots", showWarnings = FALSE)

# Determine which column to use as the sample/tissue identifier in Exp_table_long_averaged_z
sample_col <- if ("SampleName" %in% colnames(Exp_table_long_averaged_z)) "SampleName" else "tissue"

# 5.1 Identify genes strongly correlated with any bait (and include baits)
genes_to_keep <- correlation_against_baits %>%
  filter(correlation > r_cutoff, significant) %>%
  pull(Gene2) %>%
  unique()

genes_to_keep <- union(genes_to_keep, unique(correlation_against_baits$Gene1)) # include baits

message("Genes retained for downstream all-vs-all: ", length(genes_to_keep))

# 5.2 Filter main expression table and pivot wide
Expr_filtered_long <- Exp_table_long_averaged_z %>%
  filter(gene_ID %in% genes_to_keep)

Expr_filtered_wide <- Expr_filtered_long %>%
  select(gene_ID, !!sym(sample_col), z.score.TPM) %>%
  pivot_wider(names_from = !!sym(sample_col), values_from = z.score.TPM) %>%
  column_to_rownames("gene_ID")

# sanity check
if (nrow(Expr_filtered_wide) < 2) stop("Not enough genes to compute pairwise correlations after filtering.")

# 5.3 Compute gene-gene correlation matrix (genes x genes)
cor_mat <- cor(t(Expr_filtered_wide), use = "pairwise.complete.obs", method = "pearson")

# Convert to long format
cor_long <- as.data.frame(cor_mat) %>%
  tibble::rownames_to_column("Gene1") %>%
  pivot_longer(-Gene1, names_to = "Gene2", values_to = "correlation") %>%
  filter(Gene1 != Gene2)

# 5.4 Compute t-stat, p-value and FDR for correlations
# ensure n_samples is defined; if not, infer from number of columns used above
if (!exists("n_samples") || is.null(n_samples)) {
  n_samples <- ncol(Expr_filtered_wide)
  message("Inferred n_samples = ", n_samples)
}

cor_long <- cor_long %>%
  mutate(
    correlation = ifelse(correlation == 1, 0.999999, correlation),
    t_stat = correlation * sqrt((n_samples - 2) / (1 - correlation^2)),
    p_value = 2 * pt(-abs(t_stat), df = n_samples - 2)
  ) %>%
  mutate(FDR = p.adjust(p_value, method = "BH"))

# 5.5 Filter for strong & significant correlations
cor_long_filtered <- cor_long %>%
  filter(FDR < 0.05, abs(correlation) >= r_cutoff)

# remove mirror duplicates (A_B and B_A) keeping one
cor_long_filtered_unique <- cor_long_filtered %>%
  mutate(pair = paste0(pmin(Gene1, Gene2), "_", pmax(Gene1, Gene2))) %>%
  distinct(pair, .keep_all = TRUE) %>%
  select(-pair)

write_tsv(cor_long_filtered_unique, file = "results/GeneCoexpression_all_vs_all_filtered.tsv")
message("Saved filtered correlations to results/GeneCoexpression_all_vs_all_filtered.tsv")

# -------------------------------
# 6Ô∏è‚É£ Build igraph network & detect modules (Leiden)
# -------------------------------

edge_table <- cor_long_filtered_unique %>%
  rename(from = Gene1, to = Gene2, weight = correlation) %>%
  select(from, to, weight, p_value = p_value, FDR = FDR)

node_table <- tibble(gene_ID = unique(c(edge_table$from, edge_table$to)))

# construct igraph object
my_network <- graph_from_data_frame(edge_table, vertices = node_table, directed = FALSE)

cat("Network built: ", vcount(my_network), "nodes,", ecount(my_network), "edges\n")

# Leiden resolution optimization (uses optimize_resolution() from your FUNCTIONS.R)
# fallback if optimize_resolution not present: pick resolution = 1
if (!exists("optimize_resolution")) {
  warning("optimize_resolution() not found in environment. Using resolution = 1 as fallback.")
  resolution <- 1
} else {
  future::plan(multisession, workers = 1)
  res_seq <- seq(0.25, 5, by = 0.25)
  opt_res_df <- future_map_dfr(
    res_seq,
    ~ {
      res_out <- optimize_resolution(network = my_network, resolution = .x, minGenes = minGenes)
      # assume optimize_resolution returns c(num_module, num_contained_gene)
      data.frame(resolution = .x,
                 num_module = as.numeric(res_out[1]),
                 num_contained_gene = as.numeric(res_out[2]))
    },
    .options = furrr_options(seed = TRUE)
  )
  # choose the resolution associated with the maximum number of contained genes; if ties, choose largest resolution
  best_row <- opt_res_df %>%
    filter(num_contained_gene == max(num_contained_gene, na.rm = TRUE)) %>%
    slice_tail(n = 1)
  resolution <- best_row$resolution
  message("Selected resolution = ", resolution)
}

# run Leiden (cluster_leiden should be available via igraph >=2.0)
modules_ <- cluster_leiden(my_network, resolution_parameter = resolution, objective_function = "modularity")
# If your igraph has alternate argument name:
if (is.null(membership(modules_)) && "membership" %in% methods(class = class(modules_))) {
  modules_ <- cluster_leiden(my_network, resolution = resolution, objective_function = "modularity")
}

my_network_modules <- tibble(
  gene_ID = names(membership(modules_)),
  module = as.integer(membership(modules_))
) %>%
  inner_join(node_table, by = "gene_ID") %>%
  group_by(module) %>%
  filter(n() >= minGenes) %>%
  ungroup()

cat("Modules detected (after filtering minGenes):", n_distinct(my_network_modules$module), "\n")

# save modules
write_tsv(my_network_modules, file = "results/GeneCoex_geneModules.tsv")
message("Saved module assignments to results/GeneCoex_geneModules.tsv")

# -------------------------------
# 7Ô∏è‚É£ Module expression summaries & heatmap
# -------------------------------

# ensure metadata tissue names are cleaned the same way
metadata <- metadata %>%
  mutate(tissue = gsub("_|\\s+", "", tissue),
         TissueOrdered = if (!"TissueOrdered" %in% colnames(metadata)) factor(tissue) else TissueOrdered)

# prepare expression table for module summary (use sample_col)
expr_for_modules <- Exp_table_long_averaged_z %>%
  inner_join(my_network_modules, by = "gene_ID") %>%
  mutate(!!sample_col := gsub("_|\\s+", "", !!sym(sample_col)))  # clean sample names

modules_mean_z <- expr_for_modules %>%
  group_by(module, !!sym(sample_col)) %>%
  summarise(mean.z = mean(z.score.TPM, na.rm = TRUE), .groups = "drop") %>%
  rename(tissue = !!sym(sample_col))

# genes per module
genes_per_module <- expr_for_modules %>%
  group_by(module) %>%
  summarise(n = n_distinct(gene_ID), .groups = "drop")

# assemble heatmap data and ordering
heatmap_data <- modules_mean_z %>%
  left_join(metadata %>% select(TissueOrdered, tissue), by = "tissue") %>%
  full_join(genes_per_module, by = "module") %>%
  arrange(desc(n)) %>%
  mutate(ordered_modules = factor(module, levels = unique(module)))



##heatmap
module_heatmap <- heatmap_data %>%
  ggplot(aes(x = TissueOrdered, y = ordered_modules)) +
  geom_tile(aes(fill = mean.z), color = "grey80") +
  scale_fill_gradient2(
    mid = "white", high = "#67001F", low = "#053061",
    breaks = c(-1.5, 0, 1.5), labels = c("< -1.5", "0", "> 1.5")
  ) +
  labs(
    x = "Tissue", y = "Module", fill = "z-score",
    caption = paste0("r ‚â• ", r_cutoff, ", FDR < 0.05, resolution = ", resolution)
  ) +
  heatmap_theme +
  theme(
    axis.text.x = element_text(angle = -45, hjust = 0, vjust = 1)  # <-- rotate tissue labels
  )
module_heatmap_nGenes <- heatmap_data %>%
  select(ordered_modules, n) %>%
  unique() %>%
  ggplot(aes(y = ordered_modules, x = "", label = n)) +
  geom_tile(fill = "white", color = "white") +
  geom_text() +
  scale_x_discrete(position = "top") +  # move x-axis to top
  labs(x = "Genes\nin\nmodule") +
  annotation_theme +
  theme(
    axis.title.x.top = element_text(hjust = 1, vjust = 0.5)  # top-right alignment
  )

wrap_plots(module_heatmap, module_heatmap_nGenes, ncol = 2, widths = c(2, 0.1))

ggsave("plots/GeneCoex_FDR_filtereddoubtnew1.svg", height = 9, width = 12, bg = "white")
ggsave("plots/GeneCoex_FDR_filtereddoubtnew1.png", height = 9, width = 12, bg = "white", dpi = 1200)

# -------------------------------
# 8Ô∏è‚É£ Network summary & save
# -------------------------------
cat("Final network summary:\n")
cat("  Nodes:", vcount(my_network), "\n")
cat("  Edges:", ecount(my_network), "\n")
cat("  Modules:", n_distinct(my_network_modules$module), "\n")

# save network and edges for downstream use
saveRDS(my_network, file = "results/GeneCoex_network.rds")
write_tsv(edge_table, file = "results/GeneCoex_edges.tsv")

message("Saved network RDS and edge list in results/")

# -------------------------------
# 9Ô∏è‚É£ Optional: list bait genes and their modules
# -------------------------------
if (exists("Baits")) {
  bait_module_table <- left_join(Baits, my_network_modules, by = "gene_ID") %>%
    arrange(module)
  write_tsv(bait_module_table, "results/Baits_with_modules.tsv")
  message("Saved bait-module mapping to results/Baits_with_modules.tsv")
}

# End of polished section
print(paste("Selected resolution:", resolution))
